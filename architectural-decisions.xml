<?xml version="1.0" encoding="UTF-8"?>
<architecturalDecisions xmlns="https://architectural-decision.cspray.io/schema/architectural-decision.xsd">
  <architecturalDecision id="SingleEntrypointDefinitionProvider" attribute="Cspray\AnnotatedContainer\ArchitecturalDecisionRecords\SingleEntrypointDefinitionProvider">
    <date>2022-07-19</date>
    <status>Accepted</status>
    <contents><![CDATA[# Allow Single Entrypoint for DefinitionProvider

## Context

A DefinitionsProvider is intended to support adding third-party services that can't be annotated to a
ContainerDefinition. It could be beneficial to attach multiple consumers so that complex third-party service setup
does not have to happen entirely in 1 implementation.

## Decision

We explicitly only allow one DefinitionsProvider to be configured when compiling your ContainerDefinition.

It would be technically possible, and even straightforward, to allow configuring multiple providers. However, doing
so would have a significant cognitive overhead and, potentially, cause what services are used in a given situation to
be vague or unclear. Specifically, third-party packages could override your definitions without you being fully
aware of it.

If you need to use multiple providers or providers implemented by third-parties then you're required to provide your
own entrypoint and compose them together or explicitly define which third-party provider you'd like to use. This way
you know precisely what code is determining the services for your application.]]></contents>
    <codeAnnotations>
      <codeAnnotation>
        <classMethod>
          <class>Cspray\AnnotatedContainer\Compile\ContainerDefinitionCompileOptionsBuilder</class>
          <method>withDefinitionProvider</method>
        </classMethod>
      </codeAnnotation>
      <codeAnnotation>
        <classMethod>
          <class>Cspray\AnnotatedContainer\Compile\ContainerDefinitionCompileOptions</class>
          <method>getDefinitionsProvider</method>
        </classMethod>
      </codeAnnotation>
      <codeAnnotation>
        <classMethod>
          <class>Cspray\AnnotatedContainer\Bootstrap\XmlBootstrappingConfiguration</class>
          <method>getContainerDefinitionConsumer</method>
        </classMethod>
      </codeAnnotation>
      <codeAnnotation>
        <classMethod>
          <class>Cspray\AnnotatedContainer\Bootstrap\BootstrappingConfiguration</class>
          <method>getContainerDefinitionConsumer</method>
        </classMethod>
      </codeAnnotation>
    </codeAnnotations>
    <meta/>
  </architecturalDecision>
  <architecturalDecision id="ConfigurationCannotBeAssignedProfiles" attribute="Cspray\AnnotatedContainer\ArchitecturalDecisionRecords\ConfigurationCannotBeAssignedProfiles">
    <date>2022-08-10</date>
    <status>Accepted</status>
    <contents><![CDATA[# Configuration instances cannot be assigned profiles

## Context

Configuration instances are classes with properties that can have arbitrary values injected into them with the
#[Inject] Attribute. Like a Service, Configuration instances are shared with the Container. Unlike a Service,
Configuration cannot be assigned an explicit profile.

## Decision

We explicitly do no allow setting a profile on a Configuration. The Configuration is meant to use #[Inject] Attributes
to define values. Any value that should only be injected when certain profiles are active should have that reflected
in the #[Inject] Attribute. This way just 1 Configuration instance is required and any profile-specific values are
defined on the value itself.]]></contents>
    <codeAnnotations>
      <codeAnnotation>
        <class>Cspray\AnnotatedContainer\Attribute\Configuration</class>
      </codeAnnotation>
      <codeAnnotation>
        <class>Cspray\AnnotatedContainer\Definition\ConfigurationDefinition</class>
      </codeAnnotation>
    </codeAnnotations>
    <meta/>
  </architecturalDecision>
</architecturalDecisions>
